package libAux;
# libAux.pm
# Usage:  use libs::libAux;
# Created by Paul Ireifej 12/10/2012
#

use strict;
use warnings;
use feature "switch";
use Scalar::Util qw(openhandle);
use Carp qw(confess);
use File::Basename;
use IO::Handle;
use Fcntl;		# for sysopen's modes
# use Data::Dumper;		# good for debugging

# make key functions importable
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = qw(debug_init debug_print empty wait_for);
#our @EXPORT_OK = qw(croak debug_init debug_print empty wait_for);

# libAux.pm assumes the following parameters to exist in the parent script, defined using 'our':
#	- $DEBUG
#	- %flags (specifically, $flags{'tmp'})		# FIXME: remove this dependency (use %args instead?)
#	- $production_slow_down

# Global variables used throughout this package
my $LOG;		# filehandle - use a scalar var to get proper scope
my $log_file = "";	# the filename for $LOG
my $failure_code = "xxFAILEDxx";	# the string for flagging a failure in the log_file (until log_init() gives us real value)
my $DBG;		# filehandle
my $DBG_file = "";	# the filename for $DBG

# text label constants
use constant {
	list_surv => "List Surveillance",
	act_surv => "Activate Surveillance",
	acti_surv => "Activate IRI Surveillance",
	actc_surv => "Activate CCC Surveillance",
	deact_surv => "Deactivate Surveillance",
};

# provisioning (or de-provisioning) command prefixes
use constant {
	add => "add",
	del => "delete",
	dsp => "display",
};

# Parameter notes, used for the arg_defs comments as well as
# the 'title' HTML property (tool tips) for any web pages.
#
# NOTE: Keep in alphabetical order!
#
use constant {
	access_note => "Type of access required for this court order",
	access_type_note => "Type of access to node by ELEAT",
	action_note => "Action to be performed; does not appear in the output of the DISPLAY command",
	AFID_note => "Identity assigned to the Access Function",
	associated_node_note => "List of other nodes associated with this node, delimited with '+'",
	BILL_NUM_note => "Specifies the billing number to which CCC is to be billed",
	case_ID_note => "A unique ID for a surveillance (typically generated by ELEAT)",
	CC_show_target_note => "Specifies whether or not the target must be suppressed when setting up a CC channel to an LEA",
	CCC_ID_note => "Identity of the CCC for this surveillance: the value defined in this parameter is sent to the law enforcement collection function in the CCOpen and CCClose messages as the CCC Identity",
	CDCDFIPADD_note => "Associated Node IP Address",
	CDCDFPORT_note => "Associated Node Port Number",
	cddf_note => "The name of the CDDF gateway to be used by this node",
	CDPNAI_note => "The ISUP Nature of Address indicator in the ISUP Called Party Number parameter",
	CDPPLAN_note => "The ISUP Numbering Plan indicator in the ISUP Called Party Number parameter",
	CF_name_note => "The name of the collection function, to be mapped to the CFID",
	CGPNAI_note => "The ISUP Nature of Address indicator in the ISUP Calling Party Number parameter",
	CGPNUM_note => "The ISUP Calling Party Number parameter to be used when initiating a call to a directory number",
	CGPPLAN_note => "The ISUP Numbering Plan indicator in the ISUP Calling Party Number parameter",
	CHRGNAI_note => "The ISUP Nature of Address indicator in the ISUP Charge Number parameter",
	CHRGNUM_note => "The number used to charge the call",
	CHRGPLAN_note => "The ISUP Numbering Plan indicator in the ISUP Charge Number parameter",
	CI_show_target_note => "Specifies whether or not the target needs to be displayed in the call data message",
	CISS_note => "Specifies whether or not CISS content is to be included in the call data message",
	city_note => "City where the court order was issued",
	CLLI_note => "The CLLI value, as taken from the node configuration file for a given node",
	CMDLINERUN_note => "A flag to govern use of HTML (or not) in DBG_PRINT output",
	cmd_wait_note => "Number of seconds to wait for a reply from the server for each command",
	CNUM_note => "The Dialed Telephone (voice delivery) number(s) (\"+\" separated)",
	COID_note => "Identity assigned to the court order: this parameter is the same as the coid in the CO managed object",
	combined_note => "Specifies whether the circuit-switched voice is to be delivered combined or separately",
	COMM_note => "Kodiak Communication ID",
	command_note => "Uses the ACTIONTYPENUM and node config NODECLASS to formulate a command given to the session script",
	comments_note => "Comments about the court order",
	connect_state_note => " State of the connection between the delivery function and the collection function",
	contact_note => "Nickname of the contact person at the LEA; the value is referenced to the value of the nickname parameter in the Contact managed object",
	CPND_note => "Specifies whether the Calling Party Number Display must be delivered to the LEA",
	CRSS_note => "Mobile Initiated Call Related",
	DCSID_note => "Defines the identity assigned to the DCS",
	DDE_note => "Specifies whether or not the Dialed Digit Extraction Data must be delivered to the collection function",
	DEBUG_note => "A DEBUG level to use for the current invocation",
	dest_IP_note => "IP address of the collection function in the IP network",
	dest_port_note => "Server port number to be used for the connection to the collection function",
	DN_note => "Directory number to be dialed out",
	ECPID_note => "Identity of the ECP",
	Email_note => "Email ID(s) (\"+\" separated) ",
	ENCRYPTION_note => "Type of encryption algorithm",
	failure_note => "String we put in the log file when session fails",
	filter_note => "FILTER is added to allow the administrator to specify the media type of content that can be passed through to Collection Function",
	FromTgtTelNo_note => "Telephone number FROM the Target.  It is a string.",
	full_locate_note => "Specifies whether full locate is to be performed Yes or No",
	group_note => "Group name",
	GRPID_note => "Specifies the trunk group number for the call content delivery from the Lucent MSC to the delivery function (Note: This parameter specifies the TGL RLS(Router List Selector) field when the method is CALLTIME)",
	if_ID_note => "Identity assigned to the T1.678 collection function interface",
	IMMBILL_note => "Specifies the value of the immediate billing identifier used for subscriber billing in the Lucent MSC in the LAES form",
	IMSI_note => "An IMSI is comprised of 15 digits",
	INCPTTYPE_note => "Kodiak Intercepted Type",
	IOBS_note => "In-band and out-of-band signalling",
	ITN_note => "Internal Tracking Number used by the NCC & NSCC",
	JAREAID_note => "The Jurisdiction Area Identity that identifies a group of Access Functions",
	judge_note => "Name of the judge who issued the court order",
	key_note => "Public key used for encryption",
	kpi_note => "Specifies whether statistics are to be gathered or not for the surveillance",
	LEA_CFID_note => "Collection Function Identifier used for the LEA",
	LIID_note => "LIID is comprised of MDN + MUID as the last digit",
	location_note => "Specifies whether or not location information is to be included in the call data message",
	media_restrict_note => "Specify whether to apply custom BroadWorks call content restrictions",
	MDN_note => "Mobile phone number (also MSISDN)",
	member_note => "Specifies the starting member in the GRPID trunk group that is used for the call content delivery from the Lucent MSC to the LTDU (Note: This parameter corresponds to the start primay BTM parameter in the LAES form in ECP 15.1 or later releases when bridge trunks are used)",
	MIN_note => "Mobile Identification Number (TDMA traces) or \nInternational Mobile Subscriber Identifier (GSM/PACKET traces).\n\nEntering the MIN for TDMA traces will skip the MIN lookup",
	MML_prompt_note => "MML prompt",
	MRP_note => "Specifies if the Monitoring Replacement Parties are allowed for the surveillance",
	MUID_note => "ELEAT seq num for this case on this MDN",
	NCIS_note => "Network Initiated Call Independent",
	NCRS_note => " Network Initiated Call Related",
	NUMCALLS_note => "Specifies the maximum number of simultaneous, per target input circuits, that the Lucent MSC allows (Note: This parameter corresponds to the call content (c_content) parameter in the LAES form)",
	NUMCCC_note => "Specifies the maximum number of trunks that should be used concurrently for this target to send call content to the delivery function. (Note: This parameter corresponds to the number of BTM pairs(b_del_info.nbtmp[1..16]) parameter and (del_info.ntrkm[1..16]) parameter in the LAES form in ECP 15.1 or later release)",
	object_note => "The subject of the action being performed",
	OLI_note => "The value of the ISUP Originating line information parameter",
	order_date_note => "Date the court order was issued by the judge",
	own_IP_note => "Xcipio own IP address to be used for this interface",
	owner_note => "The name of the user who configured this entry into the database",
	own_port_note => "Xcipio own port number to be used for this interface",
	password_note => "Password on node with which ELEAT logs in (max 25 chars)",
	PKTCONT_note => "Specifies whether or not the packet envelope content must be delivered to the collection function",
	PKTENV_note => "Specifies whether the packet envelope message must be delivered to the collection function",
	PRIIP_note => "Primary IP address for the server",
	PRIPORT_note => "Primary TCP/IP port on the server",
	priority_note => "This parameter specifies the order in which to use CCCs: the lower the number, the higher the priority",
	received_date_note => "Date the court order was received by the service provider",
	received_time_note => "Time of day the court order was received by the service provider",
	REFID_note => "Kodiak Reference ID",
	region_note => "Region where the court order was issued",
	reportheldcall_note => "Specify whether call content should be delivered for calls being held by the subject.",
	reportrtcp_note => "Specify whether the RTCP stream corresponding to the RTP media is to be intercepted",
	req_state_note => "Required state for the connection to the collection function",
	requestor_note => "user responsible for this request",
	RtpNetId_note => "It is associated with NETID of NETWORK to represent RTP source IP address for the Call Content delivery to PSTN Media Gateway. The default value is an empty ID.",
	services_note => "Services",
	service_ID_note => "Identity of the target",
	service_type_note => "Type of target service",
	SMS_note => "Specifies whether or not SMS content needs to be included in the call data message",
	source_note => "the source of this current invocation",
	start_date_note => "Date this surveillance is to start according to the court order",
	start_time_note => "Time of day this surveillance is to start according to the court order",
	state_note => "State where the court order was issued",
	status_note => "Status of the circuit after provisioning the CCC",
	stop_date_note => "Date this surveillance is to stop according to the court order",
	stop_time_note => "The time of day this surveillance is to stop according to the court order",
	subject_signal_note => "Specify whether signals initiated by the intercept subject should be reported in a SubjectSignal T1678 message",
	success_note => "String we put in the log file when session is successful",
	surveillance_type_note => "Type of surveillance (call data or call content to be intercepted). PEN data is to be intercepted only for all calls originated by the subject. TRACE data is to be intercepted only for all calls terminated by the subject",
	TID_note => "Target identity assigned to the target; this parameter is the same as the tid parameter in the Target managed object",
	time_zone_note => "Time zone of the provisioning",
	ToTgtTelNo_note => "Telephone number TO the Target.  It is a string.",
	trace_level_note => "Trace level for this surveillance; this parameter is used for debugging purposes",
	transcript_note => "Session transcript ('tmp') filename",
	transport_note => "Transport protocol for the connection to the collection function",
	user_note => "User ID on node with which ELEAT logs in",
	version_note => "Versions of the ATIS-1000678.2006 LAES interface standards that are supported"
};

# service type list
our %service_types = (
	'EMAIL' => "E-mail",
	'EMAIL_IMAP4' => "E-mail IMAP4",
	'EMAIL_POP3' => "E-mail POP3",
	'EMAIL_SMTP' => "E-mail SMTP",
	'IP4' => "IPv4",
	'IP6' => "IPv6",
	'DHCP-MAC' => "DHCP-MAC",
	'LOGIN' => "Login",
	'DHCP-OPT82' => "DHCP-OPT82",
	'RADIUS-CSI' => "RADIUS-CSI",
	'IMSI' => "IMSI",
	'IMEI' => "IMEI",
	'MIN' => "MIN",
	'MSISDN' => "MSISDN",
	'TRUNK_CLLI' => "TRUNK CLLI",
	'CASEID' => "Case ID",
	'MDN' => "MDN",
	'IN' => "IN",
	'DN' => "DN",
	'PARTIAL_DN' => "Partial DN",
	'FDN' => "FDN",
	'ESN' => "ESN",
	'URI' => "URI",
	'ATM-PVC' => "ATM PVC",
	'FTP-NAME' => "FTP Name",
	'IRC-NAME' => "IRC Name",
	'IRC-NICK' => "IRC Nick",
	'IRC-REAL' => "IRC Real",
	'SIP-URI' => "SIP URI",
	'SIPS-URI' => "SIPS URI",
	'TEL-URI' => "Tel. URI",
	'SIP-DISPLAY' => "SIP Display",
	'ATM-SLOT-PVC' => "ATM SLOT PVC",
	'SEARCH-STR' => "Search String",
	'ADV-SEARCH-STR' => "Advanced Search String",
	'CALLING-STN-ID' => "Calling STN ID",
	'MEID' => "MEID",
	'USR-NUM' => "Username",
	'USR-NUM-PREFIX' => "Username Prefix",
	'CHAT_ICQ_LOGIN' => "Chat ICQ Login",
	'CHAT_PALTALK_LOGIN' => "Chat PALTALK Login",
	'CHAT_PALTALK_NUM' => "Chat PALTALK Number",
	'CHAT_YAHOO_LOGIN' => "Chat Yahoo Login",
	'CHAT_MSN_LOGIN' => "Chat MSN Login",
);

#
# now()
# provide the current date / time in a consistent format
#
sub now() {
	my $now = `date "+%Y/%m/%d %H:%M:%S"`;
	chomp($now);
	return $now;
} # end now()

#
# empty()
# Determine if a value is "empty:.  Test the argument and return ...
#		- true: arg is not defined or is defined but null (as a string)
#		- false: arg is defined and non-empty
# This is modeled after the PHP empty() builtin, but considering 0 to be empty causes problems.
#	FIXME: extend to accept array/hash refs & test if that array/hash is empty or not
#
sub empty($) {
	my $arg = $_[0];
	return (! defined($arg) || $arg eq "");
} # end empty()

#
# croak()
# Terminate the current process, printing any error message on stderr.
# The same message is logged, labelled with the $failure_code if $_[0] > 0 (and the log file handle is closed).
# If it looks like we've been using a debug file, then debug_print the msg, too (and close the file handle).
# Params:
#	$_[0]:	The integer status code with which to exit
#	$_[1]:	The error message to be displayed.
# If $err_msg is null, then "exit" instead, to avoid producing spurious output on stderr.
# Since the nightly audit ("exception reporting") code looks for a hard-coded failure string of "FAILED",
# force such a log message on error terminations.
#
sub croak($$) {
	my $exit_code = $_[0];
	my $err_msg = ($_[1] ne "") ? $_[1] . "\n" : "";
	if (empty($exit_code)) {
		$exit_code = 1;
		$err_msg = "(libAux::croak: exit_code undefined!)\n" . $err_msg;
	}
	my $log_msg = $err_msg;
	if ($log_msg eq "") {
		my $name = basename($0);
		$log_msg = "Exiting $name with status $exit_code\n";
	}
	my $label = ($exit_code == 0) ? "EXIT" : $failure_code;
	if (openhandle($DBG)) {
		debug_print("$label: $log_msg");
		close($DBG);
	}
	if (openhandle($LOG) && ($exit_code || $main::DEBUG)) {
		log_print($label, $log_msg);
		if ($exit_code && $failure_code ne "FAILED") {
			log_print("FAILED", $log_msg);	# for broken exception reporting code
		}
		close($LOG);
	}
	if ($err_msg eq "") {
		exit $exit_code;
		# not reached
	}
	$! = $exit_code;		# set code used by "die"
	die $err_msg;
	# not reached
} # end croak()

#
# debug_init()
# Set our local copy of $DBG_file and open it.
# Also confirm we can see $main::DEBUG.
#
sub debug_init($) {
	$DBG_file = $_[0];

	if (empty($DBG_file)) {
		croak(1, "Error: DBG filename is null!");
		# not reached
	}
	open $DBG, ">>  $DBG_file" or croak(1, "Open of DBG file '$DBG_file' failed: $!");
	$DBG->autoflush(1);

	# debug_print() needs to be guided by main::DEBUG - so make sure we can see it
	if (! defined($main::DEBUG)) {
		confess 'Error: debug_init cannot find main::DEBUG, stopped';
		# not reached
	}
} # end debug_init()

#
# log_init()
# Set our local copy of $log_file and $failure_code; open $LOG
#
sub log_init($$) {
	(my $arg, $failure_code) = ($_[0], $_[1]);
	if (empty($arg)) {
		croak(1, "Error: log filename is null!");
		# not reached
	}
	
	# note: scheduler passes in just the relative LOG file path, so add prefix IFF we are given a relative pathname
	my $ELEATROOT = libConfig::getEleatCfgVal("ELEATROOT");
	$log_file = ($arg  =~ /^\//) ? $arg : "$ELEATROOT/$arg";

	open $LOG, ">>  $log_file" or croak(1, "Open of log file '$log_file' failed: $!");
	$LOG->autoflush(1);
} # end log_init()

#
# debug_print()
# Parameters:
#		- arg0: the message to print
#		- arg1: (optional: default = 0) A two-bit vector:
#			bit0:	 prefix the output msg with a line terminator
#			bit1: ensure the output msg is terminated
# Assumes DEBUG exists in the parent script.
# Requires that debug_init() is called first, to set $DBG_file.
#
sub debug_print($;$) {
	if (! $main::DEBUG) {
		return;
	}
	if (! openhandle($DBG)) {
		confess "Error: you must call debug_init() before calling debug_print(), stopped";
		# not reached
	}
	my $msg = $_[0];
	my $term_vector = (defined($_[1])) ? $_[1] : 0;
	my $prefix_term = ($term_vector & 1);	# prefix with a line terminator?
	my $ensure_term = ($term_vector & 2);	# ensure a line termnator?
	my $prefix = ($prefix_term) ? $/ : '';
	if ($ensure_term && $msg !~ m/\R/) {
		$msg .= "$/";
	}

	print $DBG "$prefix** DBG $0: $msg";
	print STDERR "$prefix** DBG $0: $msg";
} # end debug_print()


#
# audit_print()
# Print a set of lines to the data/exceptionReports that begin with EXCEPTION_REPORT
# Requires that node_id to create a unique file along with timestamp
# Parameters:
#		- arg0: node_id
#		- arg1: log message, in the form of an array of lines.  Assumes each line is already terminated.
sub audit_print($\@) {
	my $node_id = $_[0];
	my $msg = $_[1];
	my $backslash = '/';
	my $colon = ':';

	if ( $node_id eq "" ) {
		croak (1, "GACK: NODE ID is blank! Aborting.");
	}
	if (ref $msg ne "ARRAY") {
		croak(1, "Message passed into log_print_list is not an array.");
	}

	my $ELEATROOT = libConfig::getEleatCfgVal("ELEATROOT");
	if (! defined( $ELEATROOT )) {
		croak(1,"GACK: no ELEATROOT defined! Aborting.");
	}

	my $audit_msg = "";
	for my $line (@{$msg}) {
		chomp($line);
		if ( $line =~ "^EXCEPTION_REPORT") {
			$audit_msg .= "$line\n";
		}
	}

	if ($audit_msg eq "") {
		return;
	}
	
	my $now = now();
	$now =~ s/$backslash//g;
	$now =~ s/$colon//g;
	$now =~ s/ //g;
	my $ER_LOG = $ELEATROOT . "/data/exceptionReports/" . "$now" . ":$node_id" . ":node";
	my $SCH_LOG = $ELEATROOT . "/data/exceptionReports/" . "$now" . ":$node_id" . ":sched";
	open(my $AUDIT_LOG, '>>'.$ER_LOG) or croak(1, "Failed to create $ER_LOG file check file or dir permissions or configuration env: $!");
	print $AUDIT_LOG $audit_msg;
	close($AUDIT_LOG);

	my $command = "$ELEATROOT/bin/si -c $ELEATROOT/config/CFG_Scheduler.cfg -C $node_id |grep \"^ITN\" > $SCH_LOG";
	`$command`;
}
#
# log_print_list()
# Print a set of lines to the log.
# Requires that the LOG file handle is open.
# Parameters:
#		- arg0: status code
#		- arg1: log message, in the form of an array of lines.  Assumes each line is already terminated.
sub log_print_list($\@) {
	my $status = $_[0];
	my $msg = $_[1];

	if (! openhandle($LOG)) {
		confess "Error: you must call log_init() before calling log_print_list(), stopped";
		# croak(1, "Error: you must call log_init() before calling log_print()");
		# not reached
	}

	if (ref $msg ne "ARRAY") {
		croak(1, "Message passed into log_print_list is not an array.");
	}

	my $now = now();
	my $log_msg = "$status|$now\n";

	for my $line (@{$msg}) {
		chomp($line);
		$log_msg .= "$line\n";
	}

	print $LOG $log_msg;
	return $log_msg;
} # end log_print_list()

#
# log_print_if()
# Conditionally print to the log, iff arg0 is <= main::DEBUG,
# Remaining params match log_print() (which is called).
#
sub log_print_if($$$;$) {
	if ($_[0] <= $main::DEBUG) {
		log_print($_[1], $_[2], $_[3]);
	}
} # end log_print_if()

#
# log_print()
# print to the log
# assumes LOG file handle is open
# Parameters:
#		- arg0: status code
#		- arg1: log message
#		- arg2 (optional): if non-empty, try to debug_print the $msg
#
sub log_print($$;$) {
	my ($status, $msg, $debug_flag) = ($_[0], $_[1], $_[2]);
	my $now = now();

	if (! openhandle($LOG)) {
		confess "Error: you must call log_init() before calling log_print(), stopped";
		# croak(1, "Error: you must call log_init() before calling log_print()");
		# not reached
	}

	chomp($msg);
	my $log_msg = "$status|$now|$msg\n";
	print $LOG $log_msg;
	
	if (! empty($debug_flag) && openhandle($DBG)) {
		debug_print("$msg\n");
	}

	return $log_msg;
} # end log_print()

#
# redact()
# Given an $attr and an $attr_val_str, where $attr_val_str is any string
# (typically a space- or newline-separated sequence of attr='value' terms),
# redact that attribute's "value" portion of that string.
# Useful particularly when logging command lines containing passwords.
# Args:
#	0: $attr whose value is to be redacted
#	1: the overall string to be modified
#	2 (optional): the separator between the att and its value (e.g., " => ").  Default is "=".
# Tries two variants of how "value" is quoted: once with single quotes and once with double quotes.
#
sub redact($$;$) {
	my ($attr, $attr_val_str) = ($_[0], $_[1]);
	my $sep = defined($_[2]) ? $_[2] : '=';
	$attr_val_str =~ s/ $attr$sep'[^']+'/ $attr$sep'#redacted#'/;
	$attr_val_str =~ s/ $attr$sep"[^"]+"/ $attr$sep"#redacted#"/;
	return $attr_val_str;
} # end redact()

##################################################################################
#
# Target-display functions.
# Top-level function is gen_display().  In general, node-specific session script will call *only* this display function.
#	It, in turn, calls the function to generate the specific format of display.
# Thus, to provide a new display format, create a new format-specific function,
#	and then add the format name & invocation of that function to gen_display().
# Also add that format name to libArgs::ensure_display_fmt().
#
##################################################################################

#
# gen_display()
# Args:
#		arg 0: the name of a display format (per libArgs::ensure_display_fmt()
#		arg 1: array of hashes, where each hash is a key/value pair representing the column header and the cell value, respectively
#		arg 2: array of strings, where each string is a col header, giving the order in which to generate the columns
# Return:
#		(\@display, $err_msg)
#			- @display is a set of lines, comprising the requested display
#			- \@display is valid IFF $err_msg eq ""
#
# FIXME: we may want to add support for more display formats.  Candidates: CSV|TXT|HTXT|XML
#
sub gen_display($\@\@) {
	my ($fmt, $targets_ref, $col_names_ref) = ($_[0], $_[1], $_[2]);
	my $display_ref = [];	# yes, BRACKETS, not PARENS! (to get a REF to an empty array)
	my $err_msg = "";
	
	given ($fmt) {
		when ('HTML') {
			($display_ref, $err_msg) = gen_html_target_list($targets_ref, $col_names_ref);
		}
		
		when ('PIPE') {
			($display_ref, $err_msg) = gen_piped_target_list($targets_ref, $col_names_ref);
		}
		
		when ('ERPIPE') {
			($display_ref, $err_msg) = gen_er_piped_target_list($targets_ref, $col_names_ref);
		}

		default {
			$err_msg = "libAux::gen_display: unknown display format: $fmt";
		}
	}
	return ($display_ref, $err_msg);
} # end gen_display()

#
# gen_html_target_list()
# gen_table takes two arguments and generates an HTML table display, by returning an array of strings.
# The primary purpose is for displaying the results of a "display" or "list" operation on any node.
# arg 0 - ref to array of hashes; each hash describes one target.  Each key/value pair is a col header & cell value, respectively
# arg 1 - ref to array of strings, where each string is a column header, providing the order in which to generate the columns
# Return:
#		(\@table_lines, $err_msg)
#			- \@table_lines is valid IFF $err_msg eq ""
#
sub gen_html_target_list($$) {
	my @targets = @{$_[0]};
	my @col_names = @{$_[1]};
	my @return = ();

	# start the table
	push(@return,"			<div id='list_display' style='z-index:11'>\n");
	push(@return,"				<table cellspacing='0' cellpadding='5' border='1' align='CENTER'>\n");
	
	# generate table column headings
	push(@return,"					<tr>\n");
	for my $col_name (@col_names) {
		push(@return,"						<th bgcolor='#AAAAFF'>$col_name</th>\n");
	}
	push(@return,"					</tr>\n");
	
	# generate the table content
	for my $target_ref ( @targets ) {
		my %values = %$target_ref;
		
		push(@return,"					<tr>\n");
		for my $col_name (@col_names) {
			#if (! defined($values{$col_name})) {
			#	my $err_msg = "libAux::gen_html_target_list: column header '$col_name' not found for this target";
			#	return (\@return, $err_msg);
			#	# not reached
			#}
			my $value = (defined($values{$col_name}))
				? ($values{$col_name} ne "")
					? $values{$col_name}
					: '&nbsp;'
				: '&nbsp';
			push(@return,"						<td>$value</td>\n");
		}
		push(@return,"					</tr>\n");
	}

	my $count = @targets;
	push(@return, "				<tfoot>\n");
	push(@return, "					<tr>\n");
	push(@return, "						<td><b>Total = $count</b></td>\n");
	push(@return, "					</tr>\n");
	push(@return, "				</tfoot>\n");

	# close the table
	push(@return,"				</table>\n");
	push(@return,"			</div>\n");
	
	return (\@return, "");
} # end gen_html_target_list()

#
# gen_piped_target_list()
# Args & return value as for gen_html_target_list(), above.
# The format here is specifically designed to mesh with the nightly audit process (a.k.a. "exception reporting"),
# as processed by the "generic" option within scripts/adminListSwitch.pl.
#
sub gen_piped_target_list($$) {
	my @targets = @{$_[0]};
	my @col_names = @{$_[1]};
	my @return = ();

	my $cols = join('|', @col_names);
	push(@return, "[START RECORD|$cols\n");
	for my $target_ref (@targets) {
		my %values = %$target_ref;
		my @row_vals = ();
		
		for my $col_name (@col_names) {
			# if (! defined($values{$col_name})) {
			#	my $err_msg = "libAux::gen_piped_target_list: column header '$col_name' not found for this target";
			#	return (\@return, $err_msg);
			# }
			my $value = defined($values{$col_name}) ? $values{$col_name} : '';
			push(@row_vals, $value);
		}
		my $row = join('|', @row_vals) . "\n";
		push(@return, $row);
	}
	push(@return, "[END RECORD|$cols\n");
	
	return (\@return, "");
} # end gen_piped_target_list()


#
# gen_er_piped_target_list()
# Args & return value as for gen_html_target_list(), above.
# The format here is specifically designed to mesh with the exection report process (a.k.a. "exception reporting"),
# as processed by the "generic" option within scripts/adminListSwitch.pl.
# This is a called only via commandline option of ACTIONTYPENUM=16 and DSPFMT=ERPIPE
#
# gen_er_piped_target_list()
# Args & return value as for gen_html_target_list(), above.
# The format here is specifically designed to mesh with the nightly audit process (a.k.a. "exception reporting"),
# as processed by the "generic" option within scripts/adminListSwitch.pl.
#
sub gen_er_piped_target_list($$) {
	my @targets = @{$_[0]};
	my @col_names = @{$_[1]};
	my $er_report_row;
	my @return = ();

	my $cols = join('|', @col_names);
	push(@return, "[START RECORD|$cols\n");
	for my $target_ref (@targets) {
		my %values = %$target_ref;
		my @row_vals = ();
		
		for my $col_name (@col_names) {
			my $value = defined($values{$col_name}) ? $values{$col_name} : '';
		 	$er_report_row = $col_name . '=' . $value;
			push(@row_vals, $er_report_row);
		}
		my $row = join('|', @row_vals) . "\n";
		$row =~ s/^EXCEPTION_REPORT\=/EXCEPTION_REPORT/g;
		$row =~ s/MSISDN/MDN/g;
		push(@return, $row);
	}
	push(@return, "[END RECORD|$cols\n");
	
	return (\@return, "");
} # end gen_er_piped_target_list()

#########################################################################################
#
# Functions and vars for working with the session transcript (a.k.a. "tmpfile").
# We maintain two cursors in that file, as declared below.  Each one has a character level of precision,
# so is represented by a (line number, char count) pair.
# We also maintain a window of content, that being what was *searched* in the most recent call to wait_for().
#
#########################################################################################
my $session_search_start_line = 0;		# the line number cursor w/in the ssh session transcript; new look_for searches start at spot in this line
my $session_search_start_char = 0;		# the number of chars in the $session_search_start_line that we have "used".
my $session_window_start_line = 0;	# the line number cursor w/in the ssh session transcript; new wait_for searches start here
my $session_window_start_char = 0;	# the number of chars in the $session_window_start_line we have "used".
our @session_window = ();		# session transcript lines searched in most-recent wait_for() (>= $session_window_start_line.$session_window_start_char)

#
# session_peek()
# Return the requested line from the @session_window if it exists,
# and otherwise "".
#
sub session_peek($) {
	my $line_num = $_[0];
	return ($#session_window >= $line_num) ? $session_window[$line_num] : "";
} # end session_peek()

#
# set_node_line_term()
# This is a hook into look_for() to handle nodes that use a non (UNIX) standard line termination
#
my $node_line_term = $/;
sub set_node_line_term($) {
	$node_line_term = $_[0];
} # end set_node_line_term()

#
# set_window_start()
# Set the $session_window_start_line and, optionally, the $session_window_start_char.
# If the 2nd arg is omitted, it defaults to 0.
# For $session_search_start_line & _char to stay in sync.
# Generally only called BEFORE any calls to wait_for()
# (specifically if appending to an existing session transcript (tmp) file.
# 
#
sub set_window_start($;$) {
	my $start_line = $_[0];
	my $start_char = defined($_[1]) ? $_[1] : 0;
	$session_window_start_line = $start_line;
	$session_window_start_char = $start_char;
	$session_search_start_line = $start_line;
	$session_search_start_char = $start_char;
} # end set_window_start()

#
# look_for()
#
# DO NOT CALL THIS FUNCTION (except from wait_for())!
#
# Parameters:
# 		- arg0: $target:  the string for which to search in the session transcript (the so-called "tmp" file).
#			We specifically allow for the possibility of $target itself being a regEx.
# 		- arg1: $return_on_hangup:  how to respond to loss of connection: 0 => exit; non-zero => return -2
# Return:
#		- target found: index of line in $session_window that first matched
#		- target not found: -1
#		- lost connection && $return_on_hangup: -2
# The search starts from line $session_search_start_line at position $session_search_start_char and goes to the end of the current transcript.
# Matching is case-insensitive.
# Side effects:
#		- Update $session_search_start_line & _char to identify starting point in next invocation
#		- Keep @session_window current (which changes ONLY when the prior call to wait_for() succeeded
#			- Note that we strip line terminators from @session_window (as set by set_node_line_term, if not the normal newline).
#		- On success (and ONLY then), update global $session_window_start_line & _char
#
sub look_for($$) {
	my $target = $_[0];
	my $return_on_hangup = $_[1];
	# debug_print("look_for: $target\n");
	# debug_print("\twindow ptrs: search line/char; window line/char: $session_search_start_line, $session_search_start_char; " .
	#			"$session_window_start_line, $session_window_start_char\n");
	open TRANSCRIPT, $main::flags{'tmp'} or croak(1, "Failed to open TMPFILE '$main::flags{'tmp'}': $!");
	my @whole_file = <TRANSCRIPT>;
	close TRANSCRIPT;

	my @lines = @whole_file[$session_search_start_line .. $#whole_file];
	@session_window = @whole_file[$session_window_start_line .. $#whole_file];
	{
		local $/ = $node_line_term;		# affect only this block!
		chomp(@session_window);
	}
	# Remove the beginning of the first line of the @session_window so that it starts at $session_window_start_char
	if (defined($session_window[0])) {
		$session_window[0] = substr($session_window[0], $session_window_start_char);
	}
	# Now do the same for the first line of @lines, IFF that's the same as the first line of the @session_window
	if ($session_search_start_line == $session_window_start_line && defined($lines[0])) {
		$lines[0] = substr($lines[0], $session_search_start_char);
	}

	# Now actually search for target.
	# Do it a line at a time so we capture line_num of first match.
	my $line_num = -1;
	my $matched = "";
	for (my $i = 0; $i <= $#lines; $i++) {
		# debug_print("look_for line $i: $lines[$i]", 1);
		# if (grep(/($target)/i, $lines[$i])) {
		if ($lines[$i] =~ m/($target)/i) {
			$line_num = $i;
			$matched = $1;
			last;
		}
	}

	if ($line_num >= 0) {
		# success!
		# Update our session_search_start_*, given that we found the target.
		$session_search_start_line += $line_num;
		# Now re-base $line_num relative to $session_window instead of $lines: so it is $session_window[$line_num]
		$line_num = $session_search_start_line - $session_window_start_line;
		# debug_print("look_for: found target in session_window line $line_num\n");
		if ($line_num == 0) {
			# The beginning of line $session_window[0] might have been removed.
			# So if matched within that line, there could be MULTIPLE matches on original version of that line - be sure to ignore prior ones
			#
			# Note: we must use $matched instead of $target in these 3 calls to index() so that it all works >if< $target is a regEx.
			# While a regEx works in the grep() up above, it does NOT work in index() (and so the index() fails to match!).
			#
			$session_search_start_char = $session_window_start_char + index($session_window[0], $matched) + length($matched);
		} else {
			$session_search_start_char = index($session_window[$line_num], $matched) + length($matched);
		}
		# If we found the target at the very end of its line, AND the raw version of that line is terminated, then start next search at beginning of next line.
		my $raw_line = $whole_file[$session_window_start_line + $line_num];
		if ($session_search_start_char + length($matched) + length($node_line_term) == length($raw_line) && $raw_line =~ m/\R/) {
			$session_search_start_line += 1;
			$session_search_start_char = 0;
		}

		# Identify the starting position of the window defined in our NEXT invocation.
		# Since we have a match, that next window should start at the same spot as our search.
		$session_window_start_line = $session_search_start_line;
		$session_window_start_char = $session_search_start_char;
		return $line_num;
	}
	if  (grep(/CONNECTION CLOSED BY FOREIGN HOST./i, @lines) != 0 || grep(/Connection to .* closed/, @lines) != 0)  {
		log_print(($return_on_hangup) ? 'RETRY' : $failure_code, 'Connection closed prematurely.');
		return -2 if $return_on_hangup;
		exit(1);
		# not reached #
	}
	if (grep(/UNABLE TO CONNECT TO REMOTE HOST./i, @lines) != 0) {
		log_print(($return_on_hangup) ? 'RETRY' : $failure_code, 'Unable to connect to remote host.');
		return -2 if $return_on_hangup;
		exit(1);
		# not reached #
	}

	# Update $session_search_start_line & _char to tell us where to start searching next time (given that this search failed).
	# If the last line of the transcript is complete (i.e., terminated), then start next time from the first line following what we've seen already.
	# But, if the last line is NOT terminated (e.g., no newline), then continue searching from THAT line,
	# since it may get extended before the transcript continues onto the next line.
	$session_search_start_line = $#whole_file + 1;
	if ($#whole_file >= 0 && $whole_file[$#whole_file] !~ m/\R/) {
		$session_search_start_line--;
	}
	# If we've moved beyond $session_window[0], include ALL of the first line on the next look_for() (within same wait_for()),
	# since the target might straddle what we have already and what arrives later.
	# But, if we're still in that first line, retain the current start_char value.
	if ($session_search_start_line > $session_window_start_line) {
		$session_search_start_char = 0;
	}

	# debug_print("look_for failed\n");
	return $line_num; # failure
} # end look_for()

#
# wait_for()
# Parameters:
# 		- arg0: target string for which to search in the session transcript (tmp file)
# 		- arg1: number of times to search
# 		- arg2: (optional: default = 0) return (instead of exit) on hangup?
# Return:
#		- target found: index (Å‚âÅ•0) of line in $session_window that first matched
#		- target not found: -1
#		- lost connection && $return_on_hangup: -2
# wait_for() searches for the given $target.  The search starts from the exact character position
# that immediately follows the prior SUCCESSFUL search.  The @session_window is defined to
# be the region that was searched.
# Another way to say this is that, if the search against the @session_window in one invocation of wait_for()
# fails, then the @session_window used in the NEXT invocation of wait_for() will start at the same spot.
# But if the search in the first invocation succeeds, then the @session_window used in the next invocation
# will start at the CHARACTER position immediately following the end of the prior match.
# Note that, as a result of this character-level precision, the first line of the session window (that is [0])
# may have its first portion cut off.  (E.g., if you successfully wait_for() a prompt, the first line of the
# session_window that results from the NEXT invocation of wait_for() will NOT contain that prompt,
# but only the portion of the line FOLLOWING that prompt.)
#
# The definiition of the @session_window, as well as maintenance of the cursors related to the definition of that
# window and to the searrch process, constitute side effects of wait_for() that are inherited from look_for() (which see).
#
sub wait_for($$;$) {
	my ($target, $return_on_hangup) = ($_[0], $_[2]);
	my $bar = $_[1] * 10;
	if ($bar < 10) {
		$bar = 10;
	}
	if (! defined($return_on_hangup)) {
		$return_on_hangup = 0;
	}
	# debug_print("wait_for: $target\n");
	
	for (my $counter = 0; $counter <= $bar; $counter++) {
		select(undef, undef, undef, .1);		# sleep 0.1 sec
		my $line_num = look_for($target, $return_on_hangup);
		if ($line_num == -2) {
			return -2;	# premature hangup, but the caller wants to handle it
		}
		if ($line_num >= 0) {
			# success!
			if ($main::production_slow_down) {
				sleep $main::production_slow_down;
			}
			return $line_num;
		}
	}
	
	# failure (target not found)
	# Leave $session_window pointers as they are, so the application could wait_for() a DIFFERENT target
	return -1;
} # end wait_for()


# get_candidates_range()
# Get a list of candidate file names for locking.
# Parameters
#	- min port number
#	- max port number
#	- prefix
# Accepts a port range, from min to max port number, 
# and returns an array of candidate files names
# of the form prefix:port_number
#
# Returns ("", array of candidate files) names upon success,
# Returns ("error message", empty array) upon failure
#
sub get_candidates_range($$$) {
	my $min_port_nbr = $_[0];
	my $max_port_nbr = $_[1];
	my $prefix = $_[2];
	my @candidate_file_names = ();

	if ($min_port_nbr > $max_port_nbr) {
		return ("Error: min port number $min_port_nbr is greater than the max port number $max_port_nbr\n", @candidate_file_names);
	}

	foreach my $port_nbr ($min_port_nbr .. $max_port_nbr) {
		push(@candidate_file_names, "$prefix:$port_nbr");
	}

	return ("", @candidate_file_names);
}

#
# lock()
# Ensure we have an open port.
# We'll use an set of candidate file names and a single anchor file name.
# For example, if you have the following properties:
#  MDN of 9736101066
#  ITN of 123
#  CFID of 5
#  Port range of 1234, 1235 and 1236
#  Using CVoIP
# Your candidate file names would be (CFID:port#):
#  5:1234
#  5:1235
#  5:1236
#
# The anchor file would be:
#  9736101066:123:5:CVOIP
#
# Parameters
#	- lock directory
# 	- array of candidate file names
#	- single anchor file name
# Parse list of possible port numbers from the candidate file names and allocate (lock) one of them
# for use as the port number in court order request.
#
# Returns ($port_nbr, $err_msg), where
#		- $port_nbr is the port number of the allocated port
#		- $err_msg is an error message.
#	On each invocation, exactly one of these is non-null.
#
# Use unlock() to de-allocate a port.
#
sub lock($\@$) {

	if (! defined($_[1])) {
		return ("", "no candidate file names present, so can not allocate and lock a port");
	}

	my $lock_dir = $_[0];
	my @candidates = @{$_[1]};
	my $anchor_name = $_[2];

	# Create the "anchor" file, named (uniquely) with the MDN, ITN, CFID and protocol of this case.
	# This anchor file is the first half of the lock.
	my $anchor_file = "$lock_dir/$anchor_name";
	my $success = sysopen(my $anchor_FH, $anchor_file, O_RDWR|O_CREAT|O_EXCL);
	if (! $success) {
		my $err_msg = "Creation of anchor file '$anchor_file' failed: $!\n";
		$err_msg .= "This MDN, ITN, CFID and protocol may already be in use.\n";
		$err_msg .= "Otherwise, remove stale lockfile $anchor_file & file named therein.\n";
		$err_msg .= "Try again once lockfiles have been cleared.\n";
		libAux::debug_print($err_msg);
		return ("", $err_msg . "\n" . "$anchor_file is already in use.");
		# not reached
	}
	print $anchor_FH "$anchor_name\n";
	
	# Now select the first one we can "lock".
	# Here, a lock consists of successfully creating a hard link from the $anchor_file
	# to the $lock_file (all within the $lock_dir, of course)
	# (since this linking operation is an atomic operation in the UNIX filesystem).
	# To document what each file is for, plus enable us to remove the lock upon deleting
	# the case, we write first the anchor_name and then the lock_name into that file.
	# Note: a completed lock comprises one file, containing two lines, linked under TWO names,
	# where one name is based on unique identification information (anchor) and the other name is based on the given prefix.
	my $port_nbr_list = "";
	my $comma = "";
	foreach my $lock_name (@candidates) {
		my $lock_file = "$lock_dir/$lock_name";
		if (link($anchor_file, $lock_file)) {
			# success!
			print $anchor_FH "$lock_name\n";
			close($anchor_FH);
			libAux::debug_print("Allocated $lock_name for this case.\n");
			return ($lock_name, "");
		}
		if ($! eq 'File exists') {
			my @port_nbr_array = split(':', $lock_name);
			$port_nbr_list .= $port_nbr_array[2] . $comma;
			$comma = ", ";
			next;	# this one is already locked; quietly move on
		}
		libAux::debug_print("Warning: linking $anchor_file to $lock_file failed: $! (trying next port candidate)");
	}
	close($anchor_FH);
	unlink($anchor_file);	# no good locking an anchor without an lock mate
	my $num = @candidates;
	my $lock_name_list = join(', ', @candidates);
	return ("", "no port numbers available out of $num configured ($port_nbr_list already in use) - backing out now");
} # end lock()

#
# read_lock()
# Given a lock identifier (either anchor or lock name as arg 1), attempt to read the lockfile for that lock identifier.
# Returns ($anchor_file, $lock_file, $IP_addr, $CFID, $port_nbr), where
#		- $anchor_file is the full pathname of the anchor file
#		- $lock_file is the full pathname of the corresponding lockfile
#		- $IP_addr is the IP address of the remote connection
#		- $CFID is the collection function ID being used
#		- $port_nbr is the actual port number
# If no lock is found, returns ("", "", "", "", "").
#
sub read_lock($$) {
	my $lock_dir = $_[0];
	my $lock_ID_name = $_[1];
	my $lock_ID_file = "$lock_dir/$lock_ID_name";
	my $status = open(my $lock_ID_FH, '<', $lock_ID_file);
	if (! defined($status)) {
		return ("", "", "");
	}
	my $anchor_name = <$lock_ID_FH>;
	my $lock_name = <$lock_ID_FH>;
	chomp $anchor_name;
	chomp $lock_name;
	my $lock_file = "$lock_dir/$lock_name";
	my $anchor_file = "$lock_dir/$anchor_name";
	my @port_nbr = split(':', $lock_name);
	return ($anchor_file, $lock_file, $port_nbr[0], $port_nbr[1], $port_nbr[2]);
} # end read_lock()

#
# unlock()
# Remove the lock for the given anchor, thereby releasing it for re-use.
# For security, confirm it is a valid possible lock value (no '/'!).
# Returns ($lock, $err_msg), where:
#		- On success: $lock contains the port number of the case.
#		- On failure: $err_msg is an error message.
# Exactly one of $lock & $err_msg is non-null.
#
sub unlock($$) {
	my $lock_dir = $_[0];
	my $anchor_name = $_[1];

	# if the anchor name is the full file path (i.e., includes the lock dir),
	# strip out just the file name and use that as the anchor name
	if ($anchor_name =~ $lock_dir) {
		my @file_parts = split('/', $anchor_name);
		$anchor_name = $file_parts[$#file_parts];
	}

	if ($anchor_name =~ /\//) {
		return ("", "Error: unlock given invalid anchor '$anchor_name' (no lockfile removed)");
	}
	my $anchor_file = "$lock_dir/$anchor_name";
	my $status = open(my $anchor_FH, '<', $anchor_file);
	if (! defined($status)) {
		return ("", "Error in unlock: open of anchor file $anchor_file failed: $! (lockfile not removed)");
	}
	my $skip = <$anchor_FH>;
	my $lock_name = <$anchor_FH>;		# what we want is the second line - ignore the rest

	chomp($lock_name) if defined($lock_name);
	if (! defined($lock_name) || $lock_name eq "") {
		return ("", "Error in unlock: cannot find lock_file as second line of $anchor_file (lockfile not removed)");
	}
	close($anchor_FH);

	my $lock_file = "$lock_dir/$lock_name";
	foreach my $lock_to_unlock ($lock_file, $anchor_file) {
		my $count = unlink($lock_to_unlock);
		if ($count) {
			libAux::debug_print("Removed lockfile $lock_to_unlock\n");
			next;
		}
		# unlink failed for some reason - report it
		libAux::debug_print("Error: unlock failed to unlink $lock_to_unlock: $! (human intervention required)");	# cleanup required by local human!
	}
	return ($lock_file, "");
} # unlock()

#
# repair_locks()
# If, during activation of an intercept, we got an error that the port to be allocated was already in use, then our lockfiles were wrong.  Fix 'em!
# Specifically, we obtained a fresh lock on a port that the remote server is (now) telling us was *already* in use.  Oops.
# So fix it, logging appropriate complaints along the way.
# Pivot the lock file to the newly created anchor file.
# Returns 1 on success, 0 on failure.  (If fails, caller should release existing lock.)
#
# NB: scrambled lockfiles may mean that law enforcement got the wrong intercept information!!   Tell someone!
#
sub repair_locks($$$) {
	my $lock_dir = $_[0];
	my $lock_name = $_[1];
	my $new_anchor_name = $_[2];	# guy who already has the port

	libAux::debug_print("Attempting to repair lockfiles ...\n");
	
	# Now repair the lockfiles.
	# This is akin to the latter part of code in lock(), but specifically picks up from the existing pair
	# of lockfiles that were created there.  Here are the steps:
	#		1. Remove the old anchor.
	#		2. Create the new anchor.
	#		3. Rewrite the contents of the lock to the newly created anchor.
	
	# Step 1 ...
	my $lock_file = "$lock_dir/$lock_name";
	my $status = open(my $lock_FH, '<', $lock_file);
	if (! defined($status)) {
		return ("", "Error in unlock: open of lock file $lock_file failed: $! (repair not successful)\n");
	}
	my $old_anchor_name = <$lock_FH>;
	chomp($old_anchor_name) if defined($old_anchor_name);
	my $old_anchor_file = "$lock_dir/$old_anchor_name";
	my $success = unlink($old_anchor_file);
	if (! $success) {
		libAux::debug_print("Removal of incorrect anchor file ($old_anchor_file) failed: $! (repair continues, but please remove it manually!)\n");
	}

	# Step 1 is done (perhaps unsuccessfully).  Now for step 2 ....
	my $new_anchor_file = "$lock_dir/$new_anchor_name";
	if (! link($lock_file, $new_anchor_file)) {
		# the link failed
		libAux::debug_print("Link from existing lock file ($lock_file) to new anchor file ($new_anchor_file) failed: $! (repair aborted).\n");
		return 0;
	}

	# Step 2 worked.  Now for step 3 ...
	$success = truncate($lock_file, 0);
	if (! defined($success)) {
		libAux::debug_print("Truncation of lockfile failed: $! (attempting to continue repair)\n");
	}

	$success = open($lock_FH, '+<', $lock_file);
	if (! $success) {
		libAux::debug_print("Open of $lock_file failed: $! (repair aborted)\n");
		return 0;
	}
	print $lock_FH "$new_anchor_name\n";
	print $lock_FH "$lock_name\n";
	close($lock_FH);
	libAux::debug_print("Repaired lockfile: port now locked by anchor $new_anchor_name (via $lock_file).\n");
	# Step 3 finished!
	
	return 1;
} # repair_locks()

# logout from the host
sub logout {
	$| = 1;
	print "exit:;\n";
	$| = 1;
	sleep 1;
	print "exit\n";
}

sub handle_display() {
	# get session_window index where column names begin
	my $col_start_index;
	for (my $i = 0; $i < $#libAux::session_window - 1; $i++) {
		my $line = $libAux::session_window[$i];
		if ($line =~ "-----") {
			$col_start_index = $i + 1;
			last;
		}
	}

	# get column headers and column sizes
	my @columns = ();
	my @col_sizes = ();
	for my $line (split(/(\S+\s+)/, $libAux::session_window[$col_start_index])) {
		my $size = length($line) - 1;
		if ($size > 0 ) {
			$line =~ s/^\s*([^\s]*)\s*/$1/;
			push(@col_sizes, $size);
			push(@columns, $line);
		}
	}

	# get table content
	my @list_display = ();
	my %row = ();
	my $start_index = 0;
	for (my $i = $col_start_index + 2; $i < $#libAux::session_window - 1; $i++) {
		my $line = $libAux::session_window[$i];
		#libAux::debug_print("content line = $line\n");
		for (my $col_index = 0; $col_index <= $#col_sizes; $col_index++) {
			my $size = $col_sizes[$col_index];
			my $field_val = substr($line, $start_index + $col_index, $size);
			$field_val =~ s/^\s*([^\s]*)\s*/$1/;
			$row{$columns[$col_index]} = $field_val;
			#libAux::debug_print(":$columns[$col_index]:=>:$field_val:\n");
			$start_index += $size;
		}
		my %dup = %row;
		push(@list_display, \%dup);
		%row = ();
		$start_index = 0;
	}

	if (!libAux::empty($main::flags{"object"})) {
		my ($table, $msg) = libAux::gen_display($main::flags{'display_fmt'}, @list_display, @columns);
		libAux::log_print_list("$main::flags{'success'}|LIST", @$table);
	}

	return @list_display;
}

# arg0 - full command with parameters that is used to provision
# arg1 - user-friendly description of the command being used to provision
sub handle_response($$) {
	my $cmd_full = $_[0];
	my $cmd_msg = $_[1];
	my $MML_prompt = "$main::flags{'MML_prompt'}";
	my $error_cause = "";
	chomp($cmd_full);
	chomp($cmd_msg);
	libAux::log_print_if(0, 'MML-CMD', $cmd_full);

	if (&libAux::wait_for("$MML_prompt", $main::cmd_wait) >= 0) {

		my $return = libAux::session_peek($#libAux::session_window - 1);

		if ($return =~ "<$main::flags{'success'}>") {
			libAux::log_print($main::flags{'success'}, "$cmd_msg");
			$error_cause = "";

			if ($cmd_full =~ dsp) {
				libAux::debug_print("my cmd_full = $cmd_full\n");
				handle_display();
			}
		} else {
			$return = libAux::session_peek($#libAux::session_window - 2);
			my $does_not_exist = libAux::session_peek($#libAux::session_window - 4);

			$return =~ s/<$main::flags{'failure'}>//;
			$return =~ s/:://;
			# remove white space from the left and right of this string
			$return =~ s/^\s*([^\s]*)\s*/$1/;

			# handle special case error messages
			if ($return =~ "Instance already exists") {
				$error_cause = "duplicate provisioning: $return";
			} else {
				$error_cause = $return;
			}

			# for the display commands, if no rows are returned, do not consider it as an error
			if ($does_not_exist =~ "Instance does not exist") {
				$does_not_exist = "nothing found: $return";
				return $does_not_exist;
			}

			libAux::log_print($main::flags{'failure'}, "$cmd_msg $error_cause");
		}
	}

	return $error_cause;
}

# Load all parameters from the command line into the global %flags hash.
# All values are presumed good and complete ... we assume our caller did all the validation.
# Return success/failure strings
sub initiate {
	foreach my $one (@ARGV) {
		my $index = index($one, '=');
		my $param = substr($one, 0, $index);
		my $value = substr($one, $index + 1, length($one));
		$main::flags{$param} = $value;
		libAux::debug_print("Incoming parameter: $param = $value\n");
	}

	$main::cmd_wait = $main::flags{'cmd_wait'};

	return ("$main::flags{'success'}", "$main::flags{'failure'}", "<$main::flags{'success'}>|<$main::flags{'failure'}>");	# success/failure strings
}

# log into the host (assuming access type of "SSH Level 2")
#
# Arguments:
# login name - user name to log into the remote node
# password - associated password to log into the remote node
# prompt - initial command line prompt from the remote node
# tolerance - how many times do we look for a given response?
# retry_status - exit status to use to request an *immediate* retry
#
# Return: 0 on success, non-zero on failure
#
sub login($$$$$) {
	my ($user, $passwd, $prompt, $tolerance, $retry_status) = ($_[0], $_[1], $_[2], $_[3], $_[4]);
	my $access_type = "SSH Level 2";
	my $skip_password = 0;	# if we don't get the Password prompt back, we try login without entering a password
	$| = 1;

	if (wait_for("password", $tolerance) < 0) {
		libAux::log_print("LOGIN", "$access_type - timed out waiting for password prompt during login");
		$skip_password = 1;
		# do not return here because it's possible we have SSH keys installed and thus, do not need to enter a password
	}
	sleep(1);	# without this, we sometimes overrun the remote host taking in the password.

	if (!$skip_password) {
		print "$passwd\n";	# only print password if we get a Password prompt back
	}

	my $prompt_status = wait_for($prompt, $tolerance, 1);		# we'll assess any hangups
	if ($prompt_status == -2) {
		# they hung up on us; can we tell why?
		if (grep(/No servers url were found/, @libAux::session_window) != 0) {
			log_print("RETRY", "Configuration error in connecting to blade. Retry?");
			exit($retry_status);	# immediately retry connecting
			# not reached #
		}
		exit(1);	# some other problem - just abort
	}
	if ($prompt_status == -1) {
		# no prompt, but still connected
		if (libAux::session_peek(1) =~ m/^Permission denied, please try again$/) {
			libAux::log_print("LOGIN", "Password not accepted or seen - retry?");
			return $retry_status;
		}
		libAux::log_print("LOGIN", "Missing shell prompt '$prompt' after logging in!");
		logout;
		return 1;
	}
	libAux::log_print_if(10, 'LOGIN', "Logged in as $user via $access_type");

	print "lis_mmi -nopause\n";

	if (&wait_for($main::flags{'MML_prompt'}, $main::cmd_wait) >= 0) {
		libAux::log_print_if(10, 'CSI', "Running MMI with 'lis_mmi -nopause' command");
	}

	return 0;
}

sub list_all($;\@) {
	my $node_name = $_[0];
	my @displays = @{$_[1]};
	my @targets = ();
	my $mdn = "";
	my $muid = "";
	my $coid = "";
	my $servid = "";
	my $caseid = "";
	my $min = "";

	foreach my $display(@displays) {
		my %display_hash = %$display;
		my %new_target = ();

		if (defined($display_hash{"COID"})) {
			$coid = $display_hash{"COID"};
		}
		if (defined($display_hash{"SERVID"})) {
			$servid = $display_hash{"SERVID"};
		}
		if (defined($display_hash{"CASEID"})) {
			$caseid = $display_hash{"CASEID"};
		}

		($mdn, $muid) = parse_MDN($coid);
		if ($mdn eq "") {
			($mdn, $muid) = parse_MDN($servid);
		}
		if ($mdn eq "") {
			($mdn, $muid) = parse_MDN($caseid);
		}

		if ($coid ne "" && length($coid) > 15) {
			$min = substr($coid, 0, 15);
		}

		if ($mdn ne "") {
			# also, insert any fields required for the new
			# exception reporting format, ACTIONTYPENUM 16
			$new_target{"MDN"} = $mdn;
			$new_target{"MSISDN"} = $mdn;
			$new_target{"MUID"} = $muid;
			$new_target{"NODENAME"} = $node_name;
			$new_target{"NODE_ID"} = $node_name;
			$new_target{"NODEID"} = $node_name;
			$new_target{"MIN"} = $min;
			foreach my $key ( keys %display_hash ) {
				$new_target{$key} = $display_hash{$key};
				if ($key eq "OWNER") {
					$new_target{"requestorID"} = $new_target{$key};
				}
			}
		}

		my %dup = %new_target;
		if ($mdn ne "") {
			push(@targets, \%dup);
		}

		%new_target = ();
		$mdn = "";
		$muid = "";
		$coid = "";
		$servid = "";
		$caseid = "";
	}

	return @targets;
}

# parse the given string into an MDN and MUID
sub parse_MDN($) {
	my $ID = $_[0];
	my $ID_length = length($ID);

	# completely invalid
	if ($ID eq "") {
		return ("","");
	}

	# invalid length for an MDN, but want to report it anyway.. has no MUID
	if ($ID_length <= 10) {
		return ("$ID", "");
	}

	# this must be an IMSI, *not* an MDN
	# length 15 is for IMSI alone
	# length 16 is for IMSI + MUID
	if ($ID_length == 15 || $ID_length == 16) {
		return ("","");
	}

	# the first 10-digits is the MDN.. everything else is the MUID
	return(substr($ID, 0, 10), substr($ID, 10, $ID_length - 10));
}

# merge code
# list of targets, merged from display outputs based on MDN, that includes fields MDN, MUID and NODENAME
sub merge_targets(\@) {
	my $targets_ref = $_[0];
	my @targets = @{$targets_ref};
	my %mdn_to_index = ();
	my @merged_targets = ();	# merged targets, based on MDN
	my $index = 0;

	libAux::debug_print(length(@targets));
	libAux::debug_print("-----------------------\n");
	foreach my $target (@targets) {
		my %target_hash = %$target;
		my $mdn = $target_hash{"MDN"};
		libAux::debug_print("mdn being processed = $mdn\n");
		if (!defined($mdn_to_index{$mdn})) {
			# this mdn has not yet been processed, so add it to the array
			libAux::debug_print("mdn not yet processed = $mdn\n");
			$mdn_to_index{$mdn} = $index;
			libAux::debug_print("printing mdn_to_index...\n");
			foreach my $key ( keys %mdn_to_index ) {
				libAux::debug_print("$key => $mdn_to_index{$key}\n");
			}
			my %new_hash = %target_hash;
			push(@merged_targets, \%new_hash);
			libAux::debug_print("printing merged_targets...\n");
			libAux::debug_print("size = $#merged_targets + 1\n");
			for my $item (@merged_targets) {
				libAux::debug_print("----------------------\n");
				my %item_hash = %$item;
				foreach my $key ( keys %item_hash) {
					libAux::debug_print("	$key => $item_hash{$key}\n");
				}
			}
			$index++;
		} else {
			# this mdn exists, so access the existing entry and add new properties
			libAux::debug_print("mdn being updated = $mdn\n");
			my $mdn_index = $mdn_to_index{$mdn};
			foreach my $key ( keys %target_hash ) {
				#my %tmp_head = $merged_targets[$mdn_index];
				#$tmp_head{$key} = $target_hash{$key};
				$merged_targets[$mdn_index]{$key} = $target_hash{$key};
				libAux::debug_print("	$key => $merged_targets[$mdn_index]{$key}\n");
			}
		}
	}

	libAux::debug_print("\nprinting output...\n");
	foreach my $target(@merged_targets) {
		libAux::debug_print("------------------------\n");
		my %target_hash = %$target;
		foreach my $key ( keys %target_hash) {
			libAux::debug_print("$key => $target_hash{$key}\n");
		}
	}
	return @merged_targets;
}

# set $flags{'cfid'} with the CFID value, given the CLLI
# also, set the min and max port from the NAME field of the collection function
sub set_CFID() {
	my $succ_or_fail = "<$main::flags{'success'}>|<$main::flags{'failure'}>";
	my $display_cmd = "display-cf:name=$main::flags{'CF_name'};\n";

	if (!libAux::empty($main::flags{'cfid'})) {
		$display_cmd = "display-cf:cfid=$main::flags{'cfid'};\n";
	}

	print $display_cmd;

	my ($min_port, $max_port) = (0,0);
	if (&libAux::wait_for($succ_or_fail, $main::cmd_wait) >= 0) {
		for my $line (@libAux::session_window) {
			chomp($line);

			if ($line =~ m/^(\d+)\s+(\S+)\s+/) {
				$main::flags{'cfid'} = $1;
				my $CF_name = $2;
				# for testing Type 2 LEA only
				#$CF_name = "PORT:41234-51000";
				if ($CF_name =~ m/PORT/) {
					my @CF_name_with_port = split('PORT', $CF_name);
					if ($CF_name_with_port[1] =~ m/^[-_|:]?(\d+)-(\d+)/) {
						debug_print("it is = $CF_name_with_port[1]\n");
						$min_port = (!defined($1)) ? 0 : $1;
						$max_port = (!defined($2)) ? 0 : $2;
					}
				}
				last;
			}
		}
	}

	# each warrant consumes a unique port for Type 1 LEA
	# Type 1 LEA is when min_port == max_port
	if (($min_port > 0) && ($min_port == $max_port)) {
		$min_port++;
		$max_port++;
	}

	return ($min_port, $max_port);
}

# prints comments into the session prompt
sub print_comment($) {
	my $err_msg = $_[0];
	my $pound = "#";
	my @err_msg_lines = split("\n", $err_msg);
	for my $line (@err_msg_lines) {
		if ($line eq "") {
			next;
		}
		if (libAux::wait_for($main::flags{'MML_prompt'}, $main::cmd_wait) >= 0) {
			print "$pound$line:;\n";
		}
	}
}

1;
